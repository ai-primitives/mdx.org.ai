#!/usr/bin/env node

const debug = true;
const log = (...args: any[]) => debug && console.log(...args);

// Enhanced unhandled rejection handler with detailed logging
process.on('unhandledRejection', (reason, promise) => {
  console.error('\n=== Unhandled Rejection Details ===');
  console.error('Promise:', JSON.stringify(promise, null, 2));
  console.error('Reason:', JSON.stringify(reason, (key, value) => {
    if (value instanceof Error) {
      return {
        ...value,
        name: value.name,
        message: value.message,
        stack: value.stack
      };
    }
    return value;
  }, 2));
  process.exit(1);
});

import { join, resolve, isAbsolute, dirname } from 'path';
import { existsSync } from 'fs';
import { mkdir, writeFile } from 'fs/promises';
import { glob } from 'glob';
import {
  parseMDXFile,
  type MDXParseResult,
  type ValidMDXParseResult,
  type MDXMetadata,
  isValidMetadata
} from '../packages/mdx-types/src/utils/mdx-parser.js';
import { fileURLToPath } from 'url';
import { promises as fsPromises } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface TypeGenerationError extends Error {
  code?: string;
  stack?: string;
}

async function generateTypeDefinitions(files: ValidMDXParseResult[]): Promise<string> {
  try {
    log('[Type Generation] Starting type definition generation...');
    log('[Type Generation] Processing files:', files.length);

    const file = `// Generated by generate-types.ts
// DO NOT EDIT THIS FILE DIRECTLY

declare module '*.mdx' {
  import type { MDXContent } from '@mdx-js/react';
  const component: MDXContent;
  export default component;
}

`;

    const interfaces = new Map<string, Set<string>>();

    for (const result of files) {
      try {
        if (!result?.metadata?.$type) {
          console.warn('[Type Generation] Skipping file with invalid metadata:', result);
          continue;
        }

        const type = result.metadata.$type.replace(/^https:\/\/mdx\.org\.ai\//, '');
        if (!interfaces.has(type)) {
          interfaces.set(type, new Set());
        }

        const properties = interfaces.get(type)!;
        for (const [key, value] of Object.entries(result.metadata)) {
          if (value !== undefined) {
            properties.add(key);
          }
        }
      } catch (error) {
        console.error('[Type Generation] Error processing file:', {
          error: error instanceof Error ? {
            name: error.name,
            message: error.message,
            stack: error.stack
          } : error,
          metadata: result.metadata
        });
      }
    }

    log('[Type Generation] Generating interface definitions...');
    const baseInterface = `export interface MDXFrontmatter {
  $type: string;
  title: string;
  description: string;
  $context?: string;
  $id?: string;
  [key: string]: any;
}\n\n`;

    let output = file + baseInterface;

    for (const [type, properties] of interfaces) {
      try {
        const interfaceName = `${type}Frontmatter`;
        const propertyDefinitions = Array.from(properties)
          .sort()
          .map(prop => `  ${prop}: any;`)
          .join('\n');

        output += `export interface ${interfaceName} extends MDXFrontmatter {\n${propertyDefinitions}\n}\n\n`;
      } catch (error) {
        console.error(`[Type Generation] Error generating interface for type ${type}:`, {
          error: error instanceof Error ? {
            name: error.name,
            message: error.message,
            stack: error.stack
          } : error,
          properties: Array.from(properties)
        });
      }
    }

    log('[Type Generation] Type definitions generated successfully');
    return output;
  } catch (error) {
    console.error('[Type Generation] Fatal error in generateTypeDefinitions:', {
      error: error instanceof Error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : error
    });
    throw error;
  }
}

function isValidParseResult(result: MDXParseResult | null): result is ValidMDXParseResult {
  if (!result) return false;
  const metadata = result.metadata;
  return (
    metadata !== null &&
    typeof metadata === 'object' &&
    typeof metadata.$type === 'string' &&
    typeof metadata.title === 'string' &&
    typeof metadata.description === 'string'
  );
}

async function main() {
  try {
    process.on('uncaughtException', (error) => {
      console.error('[Fatal Error] Uncaught exception:', error);
      process.exit(1);
    });

    console.log('=== Starting MDX Type Generation ===');
    log('Current directory:', process.cwd());
    log('Script directory:', __dirname);

    const contentDirs = await Promise.all([
      'content',
      'packages/mdx-types/content/types'
    ].map(async (dir) => {
      const absolutePath = resolve(process.cwd(), dir);
      console.log(`[Directory Check] Checking directory: ${absolutePath}`);

      try {
        await fsPromises.access(absolutePath, fsPromises.constants.R_OK);
        console.log(`[Directory Access] Directory exists and is readable: ${absolutePath}`);
        return absolutePath;
      } catch (error) {
        console.error(`[Directory Error] Directory not accessible: ${absolutePath}`, {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        return null;
      }
    })).catch(error => {
      console.error('[Directory Error] Error in Promise.all while checking directories:', {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      return [];
    });

    const validDirs = contentDirs.filter((dir): dir is string => dir !== null);

    if (validDirs.length === 0) {
      console.warn('[Warning] No valid content directories found');
      process.exit(0);
    }

    log('Found content directories:', validDirs);

    const mdxFilesPromises = (validDirs as string[]).map(async (dir: string) => {
      try {
        console.log(`[File Search] Searching for MDX files in ${dir}...`);
        const pattern = join(dir, '**/*.mdx');
        console.log(`[File Search] Using glob pattern: ${pattern}`);

        const files = await glob(pattern).catch(error => {
          console.error(`[Glob Error] Error in glob for ${dir}:`, error);
          return [] as string[];
        });

        console.log(`[File Search] Found ${files.length} files in ${dir}:`, files);

        const validFiles = await Promise.all(
          files.map(async (file: string) => {
            try {
              await fsPromises.access(file, fsPromises.constants.R_OK);
              console.log(`[File Access] File ${file} is readable`);
              return file;
            } catch (error) {
              console.error(`[File Error] Error accessing file ${file}:`, error);
              return null;
            }
          })
        ).catch(error => {
          console.error('[Promise Error] Error checking file access:', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined
          });
          return [] as (string | null)[];
        });

        return validFiles.filter((file): file is string => file !== null);
      } catch (error) {
        console.error('[Directory Error] Error searching for MDX files:', {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        return [] as string[];
      }
    });
    console.log('[Promise] Waiting for all MDX file searches to complete...');
    const mdxFiles = await Promise.all(mdxFilesPromises).catch(error => {
      console.error('[Promise Error] Error in Promise.all while searching for MDX files:', error);
      return [] as string[][];
    });
    const allMdxFiles = mdxFiles.flat().filter(Boolean);
    console.log('[Files] Found MDX files:', allMdxFiles);

    if (allMdxFiles.length === 0) {
      console.warn('[Warning] No MDX files found');
      process.exit(0);
    }

    log('Processing files:', allMdxFiles);

    const parsePromises = allMdxFiles.map(async (filePath: string) => {
      if (!filePath) {
        log('Skipping null file path');
        return null;
      }

      const absolutePath = isAbsolute(filePath) ? filePath : resolve(process.cwd(), filePath);
      log(`Processing file with absolute path: ${absolutePath}`);

      try {
        const result = await parseMDXFile(absolutePath, true).catch(error => {
          console.error(`[Parse Error] Error parsing MDX file ${absolutePath}:`, {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined
          });
          return null;
        });

        if (!result || !result.metadata) {
          console.warn(`[Warning] No valid metadata found in ${absolutePath}`);
          return null;
        }

        if (!isValidMetadata(result.metadata)) {
          console.warn(`[Warning] Invalid metadata structure in ${absolutePath}`);
          return null;
        }

        return result;
      } catch (error) {
        console.error(`[Fatal Error] Unexpected error processing ${absolutePath}:`, {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        return null;
      }
    });
    console.log('[Progress] Waiting for parse promises to complete...');
    const parsedFiles = await Promise.all(parsePromises).catch(error => {
      console.error('[Promise Error] Error in Promise.all while parsing files:', {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      return [] as (MDXParseResult | null)[];
    });

    console.log('[Progress] Filtering valid files...');
    const validFiles = parsedFiles
      .filter((result): result is NonNullable<typeof result> => {
        if (!result) {
          console.log('[Filter] Filtering out null result');
          return false;
        }
        return true;
      })
      .filter((result): result is ValidMDXParseResult => {
        try {
          const isValid = isValidParseResult(result) && isValidMetadata(result.metadata);
          if (!isValid) {
            console.log('[Filter] Filtering out invalid result:', {
              hasMetadata: result.metadata !== null,
              isValidParseResult: isValidParseResult(result),
              isValidMetadata: result.metadata ? isValidMetadata(result.metadata) : false
            });
          }
          return isValid;
        } catch (error) {
          console.error('[Filter Error] Error validating parse result:', error);
          return false;
        }
      })
      .map((file: ValidMDXParseResult) => {
        const cleanType = file.metadata.$type.replace(/^https:\/\/mdx\.org\.ai\//, '');
        return {
          ...file,
          metadata: {
            ...file.metadata,
            $type: cleanType
          }
        } satisfies ValidMDXParseResult;
      });

    if (validFiles.length === 0) {
      console.warn('No valid MDX files found with proper frontmatter');
      process.exit(0);
    }

    log(`Successfully parsed ${validFiles.length} valid MDX files`);
    try {
      console.log('[Progress] Generating type definitions...');
      const typeDefinitions = await generateTypeDefinitions(validFiles).catch(error => {
        console.error('[Type Generation Error] Error generating type definitions:', {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        throw error;
      });

      const outputDir = resolve(__dirname, '..', 'packages/mdx-types/src/generated');
      await mkdir(outputDir, { recursive: true }).catch(error => {
        console.error('[Directory Error] Error creating output directory:', {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        throw error;
      });
      console.log('[Progress] Created output directory:', outputDir);

      const outputFile = join(outputDir, 'frontmatter.d.ts');
      await writeFile(outputFile, typeDefinitions, 'utf-8').catch(error => {
        console.error('[File Error] Error writing type definitions:', {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        throw error;
      });
      log(`Type definitions written to ${outputFile}`);

      console.log('[Success] Type generation completed successfully');
    } catch (error) {
      console.error('[Fatal Error] Error in type generation process:', {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      process.exit(1);
    }
  } catch (mainError) {
    console.error('[Fatal Error] Error in main function:', {
      error: mainError instanceof Error ? {
        ...mainError,
        name: mainError.name,
        message: mainError.message,
        stack: mainError.stack
      } : JSON.stringify(mainError, null, 2),
      type: mainError instanceof Error ? mainError.constructor.name : typeof mainError
    });
    process.exit(1);
  }
}

Promise.resolve().then(() => main()).catch(error => {
  console.error('[Fatal Error] Unhandled error in main:', {
    error: error instanceof Error ? {
      ...error,
      name: error.name,
      message: error.message,
      stack: error.stack
    } : JSON.stringify(error, null, 2),
    type: error instanceof Error ? error.constructor.name : typeof error
  });
  process.exit(1);
});
