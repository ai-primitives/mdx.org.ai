#!/usr/bin/env node

const debug = true;
const log = (...args: any[]) => debug && console.log(...args);

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise);
  if (reason instanceof Error) {
    console.error('Error:', {
      name: reason.name,
      message: reason.message,
      stack: reason.stack
    });
  } else {
    console.error('Non-Error reason:', reason);
  }
  process.exit(1);
});

import { join, resolve, isAbsolute, dirname } from 'path';
import { existsSync } from 'fs';
import { mkdir, writeFile } from 'fs/promises';
import { glob } from 'glob';
import {
  parseMDXFile,
  type MDXParseResult,
  type ValidMDXParseResult,
  type MDXMetadata,
  isValidMetadata
} from '../packages/mdx-types/src/utils/mdx-parser.js';
import { fileURLToPath } from 'url';
import { promises as fsPromises } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface TypeGenerationError extends Error {
  code?: string;
  stack?: string;
}

async function generateTypeDefinitions(files: ValidMDXParseResult[]): Promise<string> {
  try {
    log('Starting type definition generation...');

    const file = `// Generated by generate-types.ts
// DO NOT EDIT THIS FILE DIRECTLY

declare module '*.mdx' {
  import type { MDXContent } from '@mdx-js/react';
  const component: MDXContent;
  export default component;
}

`;

    const interfaces = new Map<string, Set<string>>();
    log('Processing files for type generation...');

    for (const result of files) {
      try {
        if (!result.metadata || !result.metadata.$type) {
          log('Skipping file with invalid metadata:', result);
          continue;
        }

        const type = result.metadata.$type.replace(/^https:\/\/mdx\.org\.ai\//, '');
        if (!interfaces.has(type)) {
          interfaces.set(type, new Set());
        }

        const properties = interfaces.get(type)!;
        for (const [key, value] of Object.entries(result.metadata)) {
          if (value !== undefined) {
            properties.add(key);
          }
        }
      } catch (error) {
        console.error('Error processing file for type generation:', error);
      }
    }

    log('Generating interface definitions...');
    const baseInterface = `export interface MDXFrontmatter {
  $type: string;
  title: string;
  description: string;
  $context?: string;
  $id?: string;
  [key: string]: any;
}\n\n`;

    let output = file + baseInterface;

    for (const [type, properties] of interfaces) {
      try {
        const interfaceName = `${type}Frontmatter`;
        const propertyDefinitions = Array.from(properties)
          .sort()
          .map(prop => `  ${prop}: any;`)
          .join('\n');

        output += `export interface ${interfaceName} extends MDXFrontmatter {\n${propertyDefinitions}\n}\n\n`;
      } catch (error) {
        console.error(`Error generating interface for type ${type}:`, error);
      }
    }

    log('Type definitions generated successfully');
    return output;
  } catch (error) {
    console.error('Error in generateTypeDefinitions:', error);
    throw error;
  }
}

function isValidParseResult(result: MDXParseResult | null): result is ValidMDXParseResult {
  if (!result) return false;
  const metadata = result.metadata;
  return (
    metadata !== null &&
    typeof metadata === 'object' &&
    typeof metadata.$type === 'string' &&
    typeof metadata.title === 'string' &&
    typeof metadata.description === 'string'
  );
}

async function main() {
  try {
    console.log('=== Starting MDX Type Generation ===');
    log('Current directory:', process.cwd());
    log('Script directory:', __dirname);

    const contentDirs = await Promise.all([
      'content',
      'packages/mdx-types/content/types'
    ].map(async (dir) => {
      try {
        const absolutePath = resolve(process.cwd(), dir);
        console.log(`[Directory Check] Checking directory: ${absolutePath}`);

        try {
          await fsPromises.access(absolutePath, fsPromises.constants.R_OK);
          console.log(`[Directory Access] Directory exists and is readable: ${absolutePath}`);
          return absolutePath;
        } catch (error) {
          console.error(`[Directory Error] Directory not accessible: ${absolutePath}`, error);
          return null;
        }
      } catch (error) {
        console.error(`[Resolution Error] Error resolving directory ${dir}:`, error);
        return null;
      }
    })).then(dirs => dirs.filter((dir): dir is string => dir !== null));

    if (contentDirs.length === 0) {
      console.warn('No valid content directories found');
      process.exit(0);
    }

    log('Found content directories:', contentDirs);

    const mdxFilesPromises = contentDirs.map(async (dir: string) => {
      try {
        console.log(`[File Search] Searching for MDX files in ${dir}...`);
        const pattern = join(dir, '**/*.mdx');
        console.log(`[File Search] Using glob pattern: ${pattern}`);

        const files = await glob(pattern).catch(error => {
          console.error(`[Glob Error] Error in glob for ${dir}:`, error);
          return [] as string[];
        });

        console.log(`[File Search] Found ${files.length} files in ${dir}:`, files);

        const validFiles = await Promise.all(
          files.map(async (file: string) => {
            try {
              await fsPromises.access(file, fsPromises.constants.R_OK);
              console.log(`[File Access] File ${file} is readable`);
              return file;
            } catch (error) {
              console.error(`[File Error] Error accessing file ${file}:`, error);
              return null;
            }
          })
        ).catch(error => {
          console.error(`[Promise Error] Error checking file access in ${dir}:`, error);
          return [] as (string | null)[];
        });

        return validFiles.filter((file): file is string => file !== null);
      } catch (error) {
        console.error(`[Directory Error] Error searching for MDX files in ${dir}:`, error);
        return [] as string[];
      }
    });

    console.log('[Promise] Waiting for all MDX file searches to complete...');
    const mdxFiles = await Promise.all(mdxFilesPromises).catch(error => {
      console.error('[Promise Error] Error in Promise.all while searching for MDX files:', error);
      return [] as string[][];
    });

    const allMdxFiles = mdxFiles.flat();
    console.log('[Files] All MDX files:', allMdxFiles);

    if (allMdxFiles.length === 0) {
      console.warn('[Warning] No MDX files found');
      process.exit(0);
    }

    log('Processing files:', allMdxFiles);

    const parsePromises = allMdxFiles.map(async (filePath: string) => {
      if (!filePath) {
        log('Skipping null file path');
        return null;
      }

      const absolutePath = isAbsolute(filePath) ? filePath : resolve(process.cwd(), filePath);
      log(`Processing file with absolute path: ${absolutePath}`);

      try {
        await fsPromises.access(absolutePath, fsPromises.constants.R_OK);
        log(`Verified file is readable: ${absolutePath}`);

        const result = await parseMDXFile(absolutePath, true);
        if (!result) {
          console.warn(`No result from parsing ${absolutePath}`);
          return null;
        }

        if (!result.metadata) {
          console.warn(`No metadata found in ${absolutePath}`);
          return null;
        }

        if (!isValidMetadata(result.metadata)) {
          console.warn(`Invalid metadata in ${absolutePath}:`, result.metadata);
          return null;
        }

        log(`Successfully parsed ${absolutePath}`);
        return result;
      } catch (error) {
        console.error(`Error processing ${absolutePath}:`, error);
        return null;
      }
    });

    const parsedFiles = await Promise.all(parsePromises).catch(error => {
      console.error('Error in Promise.all while parsing files:', error);
      return [];
    });

    const validFiles = parsedFiles
      .filter((result): result is NonNullable<typeof result> => result !== null)
      .filter((result): result is ValidMDXParseResult => {
        try {
          return isValidParseResult(result) && isValidMetadata(result.metadata);
        } catch (error) {
          console.error('Error validating parse result:', error);
          return false;
        }
      })
      .map((file: ValidMDXParseResult) => {
        const cleanType = file.metadata.$type.replace(/^https:\/\/mdx\.org\.ai\//, '');
        return {
          ...file,
          metadata: {
            ...file.metadata,
            $type: cleanType
          }
        } satisfies ValidMDXParseResult;
      });

    if (validFiles.length === 0) {
      console.warn('No valid MDX files found with proper frontmatter');
      process.exit(0);
    }

    log(`Successfully parsed ${validFiles.length} valid MDX files`);

    const typeDefinitions = await generateTypeDefinitions(validFiles);
    log('Generated type definitions');

    const outputDir = resolve(__dirname, '..', 'packages/mdx-types/src/generated');
    await fsPromises.mkdir(outputDir, { recursive: true }).catch(error => {
      console.error('Error creating output directory:', error);
      process.exit(1);
    });

    const outputFile = join(outputDir, 'frontmatter.d.ts');
    await fsPromises.writeFile(outputFile, typeDefinitions, 'utf-8').catch(error => {
      console.error('Error writing type definitions:', error);
      process.exit(1);
    });

    log(`Type definitions written to ${outputFile}`);
  } catch (error) {
    console.error('Error in main function:', error);
    process.exit(1);
  }
}

main().catch(error => {
  console.error('[Fatal Error] Unhandled error in main:', {
    error: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
    type: error instanceof Error ? error.constructor.name : typeof error
  });
  process.exit(1);
});
